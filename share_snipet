{
    "atcoder": {
        "prefix": "tem",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "typedef long long ll;",
            "const double EPS = 1e-9;",
            "const int INF = 1e9;",
            "const int MOD = 1e9+7;",
            "const ll LINF = 1e18;",
            "typedef vector<int> VI;",
            "typedef vector<vector<int>> VVI;",
            "typedef pair<int, int> PI;",
            "typedef pair<ll, ll> PL;",
            "typedef map<int, int> MI;",
            "typedef set<int> SI;",
            "#define VV(T) vector<vector< T > >",
            "#define dump(x)  cout << #x << \" = \" << (x) << endl",
            "#define YES(n) cout << ((n) ? \"YES\" : \"NO\"  ) << endl",
            "#define Yes(n) cout << ((n) ? \"Yes\" : \"No\"  ) << endl",
            "#define POSSIBLE(n) cout << ((n) ? \"POSSIBLE\" : \"IMPOSSIBLE\"  ) << endl",
            "#define Possible(n) cout << ((n) ? \"Possible\" : \"Impossible\"  ) << endl",
            "",
            "#define rep(i, n) REP(i, 0, n)                              // 0, 1, ..., n-1",
            "#define REP(i, x, n) for(int i = x; i < n; i++)             // x, x + 1, ..., n-1",
            "#define FOREACH(x,a) for(auto& (x) : (a) )",
            "",
            "#define ALL(v) (v).begin() , (v).end()",
            "#define RALL(v) (v).rbegin(), (v).rend()",
            "#define COUT(x) cout << (x) << endl",
            "",
            "template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }",
            "template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }",
            "",
            "",
            "int main(){",
            "    cin.tie(0);",
            "    ios::sync_with_stdio(false);",
            "",
            "}"
        ],
        "description": "atcoder"
    },
    "atcoderfor": {
        "prefix": "for",
        "body": [
            "for(${1:int} ${2:i} = 0; ${2:i} < ${3:n}; ${2:i}++) {",
            "    ${0:}",
            "}"
        ],
        "description": "atcoderfor"
    },
    "atcoderunion": {
        "prefix": "union",
        "body": [
            "class UnionFind {",
            "public:",
            "    vector <ll> par; // 各元の親を表す配列",
            "    vector <ll> siz; // 素集合のサイズを表す配列(1 で初期化)",
            "",
            "    // Constructor",
            "    UnionFind(ll sz_): par(sz_), siz(sz_, 1LL) {",
            "        for (ll i = 0; i < sz_; ++i) par[i] = i; // 初期では親は自分自身",
            "    }",
            "    // 頂点数sz_だけ初期化をする",
            "    void init(ll sz_) {",
            "        par.resize(sz_);",
            "        siz.assign(sz_, 1LL);",
            "        for (ll i = 0; i < sz_; ++i) par[i] = i; // 初期では親は自分自身",
            "    }",
            "",
            "    // Member Function",
            "    // Find",
            "    // xの属する根の検索を行う",
            "    ll root(ll x) { ",
            "        while (par[x] != x) {",
            "            x = par[x] = par[par[x]]; // x の親の親を x の親とする",
            "        }",
            "        return x;",
            "    }",
            "",
            "    // Union(Unite, Merge)",
            "    // xとyをくっ付ける。小さい方を大きい方にくっ付ける。",
            "    bool merge(ll x, ll y) {",
            "        x = root(x);",
            "        y = root(y);",
            "        if (x == y) return false;",
            "        // merge technique（データ構造をマージするテク．小を大にくっつける）",
            "        if (siz[x] < siz[y]) swap(x, y);",
            "        siz[x] += siz[y];",
            "        par[y] = x;",
            "        return true;",
            "    }",
            "    // xとyが連結をしているか判定を行う。",
            "    bool issame(ll x, ll y) { ",
            "        return root(x) == root(y);",
            "    }",
            "    // 頂点xが属する素集合のサイズを求める。",
            "    ll size(ll x) { // 素集合のサイズ",
            "        return siz[root(x)];",
            "    }",
            "};"
        ],
        "description": "atcoderunion"
    },
    "atcodergcd": {
        "prefix": "gcd",
        "body": [
            "// ユークリッドの互除法",
            "${1:int} gcd(${2:int a, ${0:int} b) {",
            "    if (b == 0) return a;",
            "    return gcd(b, a % b);",
            "}"
        ],
        "description": "atcodergcd"
    },
    "atcoderlcm": {
        "prefix": "lcm",
        "body": [
            "// 最小公倍数(lcm)",
            "${1:ll} lcm(${2:ll} a, ${0:ll} b) {",
            "    ll g = gcd(a, b);",
            "    return a / g * b;",
            "}"
        ],
        "description": "atcoderlcm"
    },
    "atcoderexgcd": {
        "prefix": "exgcd",
        "body": [
            "// 拡張ユークリッドの互除法",
            "int extgcd(int a, int b, int& x, int& y) {",
            "    int d = a;",
            "    if (b != 0) {",
            "        d = extgcd(b, a % b, y, x);",
            "        y -= (a / b) * x;",
            "    } else {",
            "        x = 1; y = 0;",
            "    }",
            "    return d;",
            "}"
        ],
        "description": "atcoderexgcd"
    },
    "atcoderprime": {
        "prefix": "prime",
        "body": [
            "// 入力はすべて正",
            "// 素数判定O(√n)",
            "bool is_prime(int n) {",
            "    for (int i = 2; i * i <= n; i++) {",
            "        if (n % i == 0) return false;",
            "    }",
            "    return n != 1; // 1の場合は例外",
            "}"
        ],
        "description": "atcoderprime"
    },
}